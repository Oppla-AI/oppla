#!/usr/bin/env bash

set -euo pipefail
source script/lib/blob-store.sh

build_flag="--release"
target_dir="release"
open_result=false
local_arch=false
local_only=false
local_install=false
bundle_name=""
can_code_sign=false

# This must match the team in the provisioning profile.
# Using full certificate name for better compatibility
IDENTITY="Developer ID Application: Insihts, Corp. (RVPAX6PXC6)"
APPLE_NOTARIZATION_TEAM="RVPAX6PXC6"

# Function for displaying help info
help_info() {
  echo "
Usage: ${0##*/} [options] [bundle_name]
Build the application bundle for macOS.

Options:
  -d    Compile in debug mode
  -l    Compile for local architecture only.
  -o    Open dir with the resulting DMG or launch the app itself in local mode.
  -i    Install the resulting DMG into /Applications in local mode. Noop without -l.
  -h    Display this help and exit.
  "
}

while getopts 'dloih' flag
do
    case "${flag}" in
        o) open_result=true;;
        d)
            export CARGO_INCREMENTAL=true
            export CARGO_BUNDLE_SKIP_BUILD=true
            build_flag="";
            target_dir="debug"
            ;;
        l)
            export CARGO_INCREMENTAL=true
            export CARGO_BUNDLE_SKIP_BUILD=true
            local_arch=true
            local_only=true
            ;;
        i) local_install=true;;
        h)
           help_info
           exit 0
           ;;
    esac
done

shift $((OPTIND-1))

if [[ $# -gt 0 ]]; then
    if [ "$1" ]; then
        bundle_name=$1
    fi
fi

# Get release channel
pushd crates/oppla
channel=$(<RELEASE_CHANNEL)
export ZED_RELEASE_CHANNEL="${channel}"
popd

export ZED_BUNDLE=true

cargo_bundle_version=$(cargo -q bundle --help 2>&1 | head -n 1 || echo "")
if [ "$cargo_bundle_version" != "cargo-bundle v0.6.1-zed" ]; then
    cargo install cargo-bundle --git https://github.com/zed-industries/cargo-bundle.git --branch zed-deploy
fi

# Deal with versions of macOS that don't include libstdc++ headers
export CXXFLAGS="-stdlib=libc++"

version_info=$(rustc --version --verbose)
host_line=$(echo "$version_info" | grep host)
local_target_triple=${host_line#*: }

# Generate the licenses first, so they can be baked into the binaries
script/generate-licenses

if [ "$local_arch" = true ]; then
    echo "Building for local target only."
    cargo build ${build_flag} --package oppla --package cli --package remote_server
else
    echo "Compiling oppla binaries"
    cargo build ${build_flag} --package oppla --package cli --target aarch64-apple-darwin --target x86_64-apple-darwin
    # Build remote_server in separate invocation to prevent feature unification from other crates
    # from influencing dynamic libraries required by it.
    cargo build ${build_flag} --package remote_server     --target aarch64-apple-darwin --target x86_64-apple-darwin
fi

echo "Creating application bundle"
pushd crates/oppla
cp Cargo.toml Cargo.toml.backup
sed \
    -i.backup \
    "s/package.metadata.bundle-${channel}/package.metadata.bundle/" \
    Cargo.toml

if [ "$local_arch" = true ]; then
    app_path=$(cargo bundle ${build_flag} --select-workspace-root | xargs)
else
    app_path_x64=$(cargo bundle ${build_flag} --target x86_64-apple-darwin --select-workspace-root | xargs)
    app_path_aarch64=$(cargo bundle ${build_flag} --target aarch64-apple-darwin --select-workspace-root | xargs)
    app_path=$app_path_x64
fi

mv Cargo.toml.backup Cargo.toml
popd
echo "Bundled ${app_path}"

if [[ -n "${MACOS_CERTIFICATE:-}" && -n "${MACOS_CERTIFICATE_PASSWORD:-}" && -n "${APPLE_NOTARIZATION_KEY:-}" && -n "${APPLE_NOTARIZATION_KEY_ID:-}" && -n "${APPLE_NOTARIZATION_ISSUER_ID:-}" ]]; then
    can_code_sign=true

    echo "====== Certificate Setup ======"
    echo "Setting up keychain for code signing..."
    
    # Delete existing keychain if it exists to avoid password conflicts
    security delete-keychain oppla.keychain 2>/dev/null || true
    
    # Create new keychain
    security create-keychain -p "$MACOS_CERTIFICATE_PASSWORD" oppla.keychain
    security default-keychain -s oppla.keychain
    security unlock-keychain -p "$MACOS_CERTIFICATE_PASSWORD" oppla.keychain
    
    # Import Apple certificates for proper chain
    echo "Importing Apple certificate chain..."
    curl -s -o /tmp/DeveloperIDG2CA.cer https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer
    curl -s -o /tmp/AppleWWDRCAG2.cer https://www.apple.com/certificateauthority/AppleWWDRCAG2.cer
    curl -s -o /tmp/AppleRootCA.cer https://www.apple.com/appleca/AppleIncRootCertificate.cer
    
    security import /tmp/DeveloperIDG2CA.cer -k oppla.keychain -T /usr/bin/codesign
    security import /tmp/AppleWWDRCAG2.cer -k oppla.keychain -T /usr/bin/codesign
    security import /tmp/AppleRootCA.cer -k oppla.keychain -T /usr/bin/codesign
    
    rm /tmp/DeveloperIDG2CA.cer /tmp/AppleWWDRCAG2.cer /tmp/AppleRootCA.cer
    
    # Import our certificate
    echo "Importing Developer ID certificate..."
    echo "$MACOS_CERTIFICATE" | base64 --decode > /tmp/oppla-certificate.p12
    security import /tmp/oppla-certificate.p12 -k oppla.keychain -P "$MACOS_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/codesign_allocate -T /usr/bin/security -A
    rm /tmp/oppla-certificate.p12
    
    # Configure keychain
    security list-keychains -d user -s oppla.keychain $(security list-keychains -d user | sed 's/\"//g')
    security set-keychain-settings -lut 21600 oppla.keychain
    security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$MACOS_CERTIFICATE_PASSWORD" oppla.keychain
    
    # Verify certificate was imported
    echo "Verifying certificate import..."
    CERT_INFO=$(security find-identity -v -p codesigning oppla.keychain | grep "$IDENTITY" || true)
    if [[ -z "$CERT_INFO" ]]; then
        echo "ERROR: Certificate '$IDENTITY' not found in keychain!"
        security find-identity -v -p codesigning oppla.keychain
        exit 1
    fi
    echo "Certificate found: $CERT_INFO"
    
    # CRITICAL: Verify TeamIdentifier is set
    echo "Verifying TeamIdentifier..."
    echo "int main(){return 0;}" > /tmp/test.c
    clang /tmp/test.c -o /tmp/test
    
    if ! codesign -s "$IDENTITY" --keychain oppla.keychain -f /tmp/test 2>/dev/null; then
        echo "ERROR: Failed to sign test binary!"
        exit 1
    fi
    
    TEAM_ID=$(codesign -dvv /tmp/test 2>&1 | grep TeamIdentifier | cut -d '=' -f2)
    rm -f /tmp/test.c /tmp/test
    
    if [[ -z "$TEAM_ID" ]]; then
        echo "ERROR: TeamIdentifier is not set in certificate!"
        echo "This certificate cannot be used for notarization."
        echo "Please create a new certificate via Xcode (not the web portal)."
        exit 1
    fi
    
    if [[ "$TEAM_ID" != "$APPLE_NOTARIZATION_TEAM" ]]; then
        echo "ERROR: TeamIdentifier mismatch!"
        echo "Expected: $APPLE_NOTARIZATION_TEAM"
        echo "Got: $TEAM_ID"
        exit 1
    fi
    
    echo "✅ TeamIdentifier verified: $TEAM_ID"
    
    # Verify designated requirements format
    echo "Verifying certificate requirements format..."
    echo "int main(){return 0;}" > /tmp/test2.c
    clang /tmp/test2.c -o /tmp/test2
    codesign -s "$IDENTITY" --keychain oppla.keychain -f /tmp/test2 2>/dev/null
    
    REQUIREMENTS=$(codesign -d -r- /tmp/test2 2>&1)
    rm -f /tmp/test2.c /tmp/test2
    
    if [[ "$REQUIREMENTS" == *"certificate root = H"* ]]; then
        echo "ERROR: Certificate generates incorrect designated requirements!"
        echo "This certificate was likely created via the web portal."
        echo "Please create a new certificate via Xcode."
        exit 1
    fi
    
    if [[ "$REQUIREMENTS" != *"anchor apple generic"* ]]; then
        echo "WARNING: Certificate may not have proper Apple anchor"
    else
        echo "✅ Certificate has proper designated requirements"
    fi

    function cleanup() {
        echo "Cleaning up keychain"
        security default-keychain -s login.keychain
        security delete-keychain oppla.keychain
    }

    trap cleanup EXIT
fi

GIT_VERSION="v2.43.3"
GIT_VERSION_SHA="fa29823"

function download_and_unpack() {
    local url=$1
    local path_to_unpack=$2
    local target_path=$3

    temp_dir=$(mktemp -d)

    if ! command -v curl &> /dev/null; then
        echo "curl is not installed. Please install curl to continue."
        exit 1
    fi

    curl --silent --fail --location "$url" | tar -xvz -C "$temp_dir" -f - $path_to_unpack

    mv "$temp_dir/$path_to_unpack" "$target_path"

    rm -rf "$temp_dir"
}

function download_git() {
    local architecture=$1
    local target_binary=$2

    tmp_dir=$(mktemp -d)
    pushd "$tmp_dir"

    case "$architecture" in
        aarch64-apple-darwin)
            download_and_unpack "https://github.com/desktop/dugite-native/releases/download/${GIT_VERSION}/dugite-native-${GIT_VERSION}-${GIT_VERSION_SHA}-macOS-arm64.tar.gz" bin/git ./git
            ;;
        x86_64-apple-darwin)
            download_and_unpack "https://github.com/desktop/dugite-native/releases/download/${GIT_VERSION}/dugite-native-${GIT_VERSION}-${GIT_VERSION_SHA}-macOS-x64.tar.gz" bin/git ./git
            ;;
        *)
            echo "Unsupported architecture: $architecture"
            exit 1
            ;;
    esac

    popd

    mv "${tmp_dir}/git" "${target_binary}"
    rm -rf "$tmp_dir"
}

function prepare_binaries() {
    local architecture=$1
    local app_path=$2

    echo "Unpacking dSYMs for $architecture"
    exe_path="target/${architecture}/${target_dir}/oppla"
    if ! dsymutil --flat "${exe_path}" 2> target/dsymutil.log; then
        echo "dsymutil failed"
        cat target/dsymutil.log
        exit 1
    fi
    uuid=$(dwarfdump --uuid "${exe_path}" | cut -d ' ' -f 2 | tr 'A-F' 'a-f')
    version="$(cargo metadata --no-deps --manifest-path crates/oppla/Cargo.toml --offline --format-version=1 | jq -r '.packages | map(select(.name == "oppla"))[0].version')"
    if [ "$channel" == "nightly" ]; then
        version="$version-$(git rev-parse --short HEAD)"
    fi

    echo "Removing existing gzipped dSYMs for $architecture"
    rm -f target/${architecture}/${target_dir}/oppla.dwarf.gz

    echo "Gzipping dSYMs for $architecture"
    gzip -f target/${architecture}/${target_dir}/oppla.dwarf

    echo "Uploading dSYMs${architecture} for $architecture to by-uuid/${uuid}.dwarf.gz"
    upload_to_blob_store_public \
        "oppla-debug-symbols" \
        target/${architecture}/${target_dir}/oppla.dwarf.gz \
        "by-uuid/${uuid}.dwarf.gz"

    cp target/${architecture}/${target_dir}/oppla "${app_path}/Contents/MacOS/oppla"
    cp target/${architecture}/${target_dir}/cli "${app_path}/Contents/MacOS/cli"

    echo "Downloading git binary for $architecture"
    download_git "${architecture}" "${app_path}/Contents/MacOS/git"

    echo "Copying provisioning profile"
    cp crates/oppla/contents/$channel/embedded.provisionprofile "${app_path}/Contents/"

    echo "Creating Frameworks directory"
    rm -rf "${app_path}/Contents/Frameworks"
    mkdir -p "${app_path}/Contents/Frameworks"
}

function sign_app_binaries() {
    local app_path=$1
    local architecture=$2
    local architecture_dir=$3
    echo "====== Signing app binaries for $architecture ======"

    if [[ $can_code_sign = true ]]; then
        echo "Signing app with deep signing approach (proven to work)..."
        
        # Remove any existing signatures first
        echo "Removing existing signatures..."
        codesign --remove-signature "${app_path}/Contents/MacOS/cli" 2>/dev/null || true
        codesign --remove-signature "${app_path}/Contents/MacOS/git" 2>/dev/null || true
        codesign --remove-signature "${app_path}/Contents/MacOS/oppla" 2>/dev/null || true
        rm -rf "${app_path}/Contents/_CodeSignature"
        
        # Sign any frameworks first if they exist
        if [ -d "${app_path}/Contents/Frameworks" ]; then
            find "${app_path}/Contents/Frameworks" -name "*.framework" -o -name "*.dylib" | while read -r framework; do
                echo "Signing framework: $framework"
                /usr/bin/codesign --force --deep \
                    --sign "$IDENTITY" \
                    --keychain oppla.keychain \
                    --options runtime \
                    --timestamp \
                    "$framework" -v
            done
        fi
        
        # Deep sign the entire app bundle with entitlements
        # This approach signs all nested binaries correctly
        echo "Deep signing app bundle..."
        /usr/bin/codesign --force --deep \
            --sign "$IDENTITY" \
            --keychain oppla.keychain \
            --options runtime \
            --timestamp \
            --entitlements crates/oppla/resources/oppla.entitlements \
            "${app_path}" -v
        
        # Verify the signature
        echo "Verifying signatures..."
        if ! codesign --verify --deep --strict "${app_path}" 2>&1; then
            echo "ERROR: Code signature verification failed!"
            echo "Attempting to diagnose..."
            codesign --verify --deep --strict --verbose=4 "${app_path}" 2>&1
            exit 1
        fi
        
        echo "✅ Code signature verification passed!"
        
        # Verify TeamIdentifier is set on all binaries
        echo "Verifying TeamIdentifier on all binaries..."
        for binary in oppla cli git; do
            TEAM_ID=$(codesign -dvv "${app_path}/Contents/MacOS/$binary" 2>&1 | grep TeamIdentifier | cut -d '=' -f2)
            if [[ "$TEAM_ID" != "RVPAX6PXC6" ]]; then
                echo "ERROR: TeamIdentifier not set on $binary! Got: '$TEAM_ID'"
                exit 1
            fi
        done
        echo "✅ All binaries have correct TeamIdentifier"
        
        # Verify designated requirements
        echo "Verifying designated requirements..."
        REQUIREMENTS=$(codesign -d -r- "${app_path}" 2>&1)
        if [[ "$REQUIREMENTS" == *"certificate root = H"* ]]; then
            echo "ERROR: Certificate has incorrect designated requirements!"
            echo "This usually means the certificate was created via web portal instead of Xcode"
            exit 1
        fi
        if [[ "$REQUIREMENTS" != *"anchor apple generic"* ]]; then
            echo "ERROR: Missing 'anchor apple generic' in requirements!"
            exit 1
        fi
        echo "✅ Designated requirements are correct"
        
    else
        echo "One or more of the following variables are missing: MACOS_CERTIFICATE, MACOS_CERTIFICATE_PASSWORD, APPLE_NOTARIZATION_KEY, APPLE_NOTARIZATION_KEY_ID, APPLE_NOTARIZATION_ISSUER_ID"
        if [[ "$local_only" = false ]]; then
            echo "To create a self-signed local build use ./scripts/build.sh -ldf"
            exit 1
        fi

        echo "====== WARNING ======"
        echo "This bundle is being signed without all entitlements, some features (e.g. universal links) will not work"
        echo "====== WARNING ======"

        # NOTE: if you need to test universal links you have a few paths forward:
        # - create a PR and tag it with the `run-bundling` label, and download the .dmg file from there.
        # - get a signing key for the MQ55VZLNZQ team from Nathan.
        # - create your own signing key, and update references to MQ55VZLNZQ to your own team ID
        # then comment out this line.
        cat crates/oppla/resources/oppla.entitlements | sed '/com.apple.developer.associated-domains/,+1d' > "${app_path}/Contents/Resources/oppla.entitlements"

        codesign --force --deep --entitlements "${app_path}/Contents/Resources/oppla.entitlements" --sign ${MACOS_SIGNING_KEY:- -} "${app_path}" -v
    fi

    if [[ "$target_dir" = "debug" && "$local_only" = false ]]; then
        if [ "$open_result" = true ]; then
            open "$app_path"
        else
            echo "Created application bundle:"
            echo "$app_path"
        fi
        exit 0
    fi

    # If bundle_name is not set or empty, use the basename of $app_path
    if [ -z "$bundle_name" ]; then
        bundle_name=$(basename "$app_path")
    else
        # If bundle_name doesn't end in .app, append it
        if [[ "$bundle_name" != *.app ]]; then
            bundle_name="$bundle_name.app"
        fi
    fi

    if [ "$local_only" = true ]; then
        if [ "$local_install" = true ]; then
            rm -rf "/Applications/$bundle_name"
            mv "$app_path" "/Applications/$bundle_name"
            echo "Installed application bundle: /Applications/$bundle_name"
            if [ "$open_result" = true ]; then
                echo "Opening /Applications/$bundle_name"
                open "/Applications/$bundle_name"
            fi
        else
            if [ "$open_result" = true ]; then
                echo "Opening $app_path"
                open "$app_path"
            fi
        fi
    else
        dmg_target_directory="target/${architecture_dir}/${target_dir}"
        dmg_source_directory="${dmg_target_directory}/dmg"
        dmg_file_path="${dmg_target_directory}/Oppla.dmg"
        xcode_bin_dir_path="$(xcode-select -p)/usr/bin"

        rm -rf ${dmg_source_directory}
        mkdir -p ${dmg_source_directory}
        mv "${app_path}" "${dmg_source_directory}"
        notarization_key_file=$(mktemp)

        echo "Adding symlink to /Applications to ${dmg_source_directory}"
        ln -s /Applications ${dmg_source_directory}

        echo "Creating final DMG at ${dmg_file_path} using ${dmg_source_directory}"
        hdiutil create -volname Oppla -srcfolder "${dmg_source_directory}" -ov -format UDZO "${dmg_file_path}"

        # If someone runs this bundle script locally, a symlink will be placed in `dmg_source_directory`.
        # This symlink causes CPU issues with Zed if the Zed codebase is the project being worked on, so we simply remove it for now.
        echo "Removing symlink to /Applications from ${dmg_source_directory}"
        rm ${dmg_source_directory}/Applications

        echo "Adding license agreement to DMG"
        npm install --global dmg-license minimist
        dmg-license script/terms/terms.json "${dmg_file_path}"

        if [[ $can_code_sign = true ]]; then
            echo "Signing DMG..."
            /usr/bin/codesign --force --deep \
                --sign "$IDENTITY" \
                --keychain oppla.keychain \
                --timestamp \
                --options runtime \
                "$(pwd)/${dmg_file_path}" -v
            
            echo "Notarizing DMG with Apple..."
            
            # Save API key to file if it's provided as content
            if [[ "$APPLE_NOTARIZATION_KEY" == *"BEGIN PRIVATE KEY"* ]]; then
                echo "API key appears to be content, saving to file..."
                echo "$APPLE_NOTARIZATION_KEY" > "$notarization_key_file"
            else
                # Assume it's a file path
                notarization_key_file="$APPLE_NOTARIZATION_KEY"
            fi
            
            # Submit for notarization with proper error handling
            echo "Submitting for notarization (this may take 5-10 minutes)..."
            SUBMISSION_OUTPUT=$("${xcode_bin_dir_path}/notarytool" submit \
                --key "$notarization_key_file" \
                --key-id "$APPLE_NOTARIZATION_KEY_ID" \
                --issuer "$APPLE_NOTARIZATION_ISSUER_ID" \
                --wait \
                "${dmg_file_path}" 2>&1)
            
            SUBMISSION_STATUS=$?
            echo "$SUBMISSION_OUTPUT"
            
            if [ $SUBMISSION_STATUS -ne 0 ]; then
                echo "ERROR: Notarization submission failed!"
                
                # Try to extract submission ID and get log
                SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep -oE '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}' | head -1)
                if [[ -n "$SUBMISSION_ID" ]]; then
                    echo "Attempting to get notarization log for submission ID: $SUBMISSION_ID"
                    "${xcode_bin_dir_path}/notarytool" log \
                        --key "$notarization_key_file" \
                        --key-id "$APPLE_NOTARIZATION_KEY_ID" \
                        --issuer "$APPLE_NOTARIZATION_ISSUER_ID" \
                        "$SUBMISSION_ID"
                fi
                
                # Clean up key file if we created it
                if [[ "$APPLE_NOTARIZATION_KEY" == *"BEGIN PRIVATE KEY"* ]]; then
                    rm "$notarization_key_file"
                fi
                exit 1
            fi
            
            # Check if notarization was accepted
            if [[ "$SUBMISSION_OUTPUT" == *"Accepted"* ]]; then
                echo "✅ Notarization accepted!"
            else
                echo "WARNING: Notarization status unclear. Output:"
                echo "$SUBMISSION_OUTPUT"
            fi
            
            # Clean up key file if we created it
            if [[ "$APPLE_NOTARIZATION_KEY" == *"BEGIN PRIVATE KEY"* ]]; then
                rm "$notarization_key_file"
            fi
            
            echo "Stapling notarization ticket..."
            if ! "${xcode_bin_dir_path}/stapler" staple "${dmg_file_path}"; then
                echo "ERROR: Stapling failed!"
                echo "Attempting to diagnose..."
                # Try to check if the DMG is actually notarized
                spctl -a -vv -t install "${dmg_file_path}" 2>&1
                exit 1
            fi
            
            echo "✅ DMG successfully notarized and stapled!"
            
            # Final verification
            echo "Final verification of notarized DMG..."
            if spctl -a -vv -t install "${dmg_file_path}" 2>&1 | grep -q "accepted"; then
                echo "✅ DMG passes Gatekeeper verification!"
            else
                echo "WARNING: DMG may not pass Gatekeeper. Output:"
                spctl -a -vv -t install "${dmg_file_path}" 2>&1
            fi
        fi

        if [ "$open_result" = true ]; then
            open $dmg_target_directory
        fi
    fi
}

function sign_binary() {
    local binary_path=$1

    if [[ $can_code_sign = true ]]; then
        echo "Code signing executable $binary_path"
        
        /usr/bin/codesign --force --deep \
            --sign "$IDENTITY" \
            --keychain oppla.keychain \
            --timestamp \
            --options runtime \
            --entitlements crates/oppla/resources/oppla.entitlements \
            "${binary_path}" -v
        
        # Verify TeamIdentifier was applied
        TEAM_ID=$(codesign -dvv "${binary_path}" 2>&1 | grep TeamIdentifier | cut -d '=' -f2)
        if [[ "$TEAM_ID" != "RVPAX6PXC6" ]]; then
            echo "ERROR: TeamIdentifier not set on $binary_path! Got: '$TEAM_ID'"
            exit 1
        fi
        echo "✅ Binary signed with TeamIdentifier: $TEAM_ID"
    fi
}

if [ "$local_arch" = true ]; then
    sign_app_binaries "$app_path" "$local_target_triple" "$local_target_triple"

    sign_binary "target/release/remote_server"
else
    # Create universal binary
    prepare_binaries "aarch64-apple-darwin" "$app_path_aarch64"
    prepare_binaries "x86_64-apple-darwin" "$app_path_x64"


    sign_app_binaries "$app_path_x64" "x86_64-apple-darwin" "x86_64-apple-darwin"
    sign_app_binaries "$app_path_aarch64" "aarch64-apple-darwin" "aarch64-apple-darwin"

    sign_binary "target/x86_64-apple-darwin/release/remote_server"
    sign_binary "target/aarch64-apple-darwin/release/remote_server"
    gzip -f --stdout --best target/x86_64-apple-darwin/release/remote_server > target/zed-remote-server-macos-x86_64.gz
    gzip -f --stdout --best target/aarch64-apple-darwin/release/remote_server > target/zed-remote-server-macos-aarch64.gz
fi

# Upload debug info to sentry.io
if ! command -v sentry-cli >/dev/null 2>&1; then
    echo "sentry-cli not found. skipping sentry upload."
    echo "install with: 'curl -sL https://sentry.io/get-cli | bash'"
else
    if [[ -n "${SENTRY_AUTH_TOKEN:-}" ]]; then
        echo "Uploading oppla debug symbols to sentry..."
        # note: this uploads the unstripped binary which is needed because it contains
        # .eh_frame data for stack unwinindg. see https://github.com/getsentry/symbolic/issues/783
        sentry-cli debug-files upload --include-sources --wait -p oppla -o oppla-dev \
            "target/x86_64-apple-darwin/${target_dir}/" \
            "target/aarch64-apple-darwin/${target_dir}/"
    else
        echo "missing SENTRY_AUTH_TOKEN. skipping sentry upload."
    fi
fi
